import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { toast } from "sonner";

export interface BudgetItem {
    id: string;
    name: string;      // e.g. "Tinta Acrílica"
    description: string; // e.g. "Suvinil Fosco Completo - Branco Neve"
    quantity: number;
    unit: string;      // e.g. "L", "Latas", "m²"
    category: string;  // e.g. "Pintura", "Estrutura"
    estimatedPrice?: number; // Optional price estimate
}

interface OrcamentoContextType {
    items: BudgetItem[];
    addItem: (item: BudgetItem) => void;
    removeItem: (id: string) => void;
    clearBudget: () => void;
    totalItems: number;
    totalEstimatedValue: number;
}

const OrcamentoContext = createContext<OrcamentoContextType | undefined>(undefined);

export const OrcamentoProvider = ({ children }: { children: ReactNode }) => {
    const [items, setItems] = useState<BudgetItem[]>(() => {
        const saved = localStorage.getItem("orcamento_items");
        return saved ? JSON.parse(saved) : [];
    });

    useEffect(() => {
        localStorage.setItem("orcamento_items", JSON.stringify(items));
    }, [items]);

    const addItem = (newItem: BudgetItem) => {
        setItems((prev) => {
            // Check if item with same ID already exists (optional logic: update quantity or add new?)
            // For simplicity, we'll allow duplicates if IDs are unique generated by components,
            // OR we can check by name/description. Let's rely on unique IDs passed by caller.
            return [...prev, newItem];
        });
        toast.success(`${newItem.name} adicionado ao orçamento!`);
    };

    const removeItem = (id: string) => {
        setItems((prev) => prev.filter((item) => item.id !== id));
        toast.info("Item removido.");
    };

    const clearBudget = () => {
        setItems([]);
        toast.warning("Orçamento limpo.");
    };

    const totalItems = items.length;
    const totalEstimatedValue = items.reduce((acc, item) => acc + (item.estimatedPrice || 0), 0);

    return (
        <OrcamentoContext.Provider value={{ items, addItem, removeItem, clearBudget, totalItems, totalEstimatedValue }}>
            {children}
        </OrcamentoContext.Provider>
    );
};

export const useOrcamento = () => {
    const context = useContext(OrcamentoContext);
    if (!context) {
        throw new Error("useOrcamento must be used within an OrcamentoProvider");
    }
    return context;
};
