import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { toast } from "sonner";
import { BudgetItem, OrcamentoContextType } from "./orcamentoTypes";

const OrcamentoContext = createContext<OrcamentoContextType | undefined>(undefined);

export const OrcamentoProvider = ({ children }: { children: ReactNode }) => {
    const [items, setItems] = useState<BudgetItem[]>(() => {
        const saved = localStorage.getItem("orcamento_items");
        return saved ? JSON.parse(saved) : [];
    });

    useEffect(() => {
        localStorage.setItem("orcamento_items", JSON.stringify(items));
    }, [items]);

    const addItem = (newItem: BudgetItem) => {
        setItems((prev) => {
            // Check if item with same ID already exists (optional logic: update quantity or add new?)
            // For simplicity, we'll allow duplicates if IDs are unique generated by components,
            // OR we can check by name/description. Let's rely on unique IDs passed by caller.
            return [...prev, newItem];
        });
        toast.success(`${newItem.name} adicionado ao orçamento!`);
    };

    const removeItem = (id: string) => {
        setItems((prev) => prev.filter((item) => item.id !== id));
        toast.info("Item removido.");
    };

    const clearBudget = () => {
        setItems([]);
        toast.warning("Orçamento limpo.");
    };

    const totalItems = items.length;
    const totalEstimatedValue = items.reduce((acc, item) => acc + (item.estimatedPrice || 0), 0);

    return (
        <OrcamentoContext.Provider value={{ items, addItem, removeItem, clearBudget, totalItems, totalEstimatedValue }}>
            {children}
        </OrcamentoContext.Provider>
    );
};

export const useOrcamento = () => {
    const context = useContext(OrcamentoContext);
    if (!context) {
        throw new Error("useOrcamento must be used within an OrcamentoProvider");
    }
    return context;
};
